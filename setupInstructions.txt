// ============================================================
// TRAIN TICKET COLLECTOR - Google Apps Script
// ============================================================
// Collects TrainPal PDF receipts from Gmail and saves to Drive.
// Naming date logic:
//   1) PRIMARY: parse travel date from ATTACHMENT filename (Option 2)
//   2) FALLBACK: parse travel date from EMAIL body/subject
//   3) FINAL fallback: email sent date
//
// Also includes a "repair" function that goes one month back,
// creates a new reconciliation folder, and re-saves last month's
// receipts into it with corrected naming.
// ============================================================

// ----- CONFIGURATION -----
var CONFIG = {
  senderEmail: "tp-accounts-noreply@trainpal.com",
  rootFolderName: "Train Tickets",
  processedLabelName: "TrainTicket-Processed",

  // Route filter: both must appear (subject/body)
  routeKeywordA: "leeds",
  routeKeywordB: "hull",

  // Only save PDF attachments containing this word in filename.
  // Set to "" to save all PDF attachments from matching emails.
  receiptKeyword: "receipt",

  // For the "repair" function: how far back to look in Gmail
  // (keeps it efficient; adjust if you book further ahead)
  repairSearchDaysBack: 90,
};

// ============================================================
// MAIN FUNCTION - Run manually or via daily trigger
// ============================================================
function collectTrainTickets() {
  var label = getOrCreateLabel_(CONFIG.processedLabelName);
  var rootFolder = getOrCreateFolderSmart_(null, CONFIG.rootFolderName);

  var query =
    "from:" +
    CONFIG.senderEmail +
    " -label:" +
    CONFIG.processedLabelName +
    " has:attachment";

  var threads = GmailApp.search(query);

  if (threads.length === 0) {
    Logger.log("No new TrainPal emails found.");
    return;
  }

  Logger.log("Found " + threads.length + " new email thread(s) to process.");

  var savedCount = 0;

  for (var t = 0; t < threads.length; t++) {
    var messages = threads[t].getMessages();

    for (var m = 0; m < messages.length; m++) {
      var message = messages[m];
      var subject = (message.getSubject() || "").toLowerCase();
      var body = (message.getPlainBody() || "").toLowerCase();
      var content = subject + " " + body;

      // Route filter
      if (
        content.indexOf(CONFIG.routeKeywordA) === -1 ||
        content.indexOf(CONFIG.routeKeywordB) === -1
      ) {
        Logger.log("Skipping email (route filter): " + message.getSubject());
        continue;
      }

      var messageDate = message.getDate();
      var attachments = message.getAttachments();

      for (var a = 0; a < attachments.length; a++) {
        var attachment = attachments[a];
        var attachmentName = (attachment.getName() || "").toLowerCase();

        if (attachment.getContentType() !== "application/pdf") continue;

        if (
          CONFIG.receiptKeyword &&
          attachmentName.indexOf(CONFIG.receiptKeyword.toLowerCase()) === -1
        ) {
          Logger.log(
            'Skipping attachment (no "' +
              CONFIG.receiptKeyword +
              '" in name): ' +
              attachment.getName()
          );
          continue;
        }

        // ----- Travel date resolution -----
        // 1) Attachment filename (primary)
        // 2) Email body/subject (fallback)
        // 3) Message date (final fallback)
        var travelDate =
          extractTravelDateFromAttachmentName_(attachment.getName(), messageDate) ||
          extractTravelDateFromEmail_(message) ||
          messageDate;

        // Folder path: Train Tickets / YYYY / MonthName
        var yearFolder = getOrCreateFolderSmart_(
          rootFolder,
          travelDate.getFullYear().toString()
        );
        var monthName = getMonthName_(travelDate.getMonth());
        var monthFolder = getOrCreateFolderSmart_(yearFolder, monthName);

        // Filename: Feb - Mon - 23-02-2026.pdf
        var fileName = buildFileName_(travelDate);
        fileName = getUniqueFileName_(monthFolder, fileName);

        monthFolder.createFile(attachment.copyBlob().setName(fileName));
        savedCount++;
        Logger.log("Saved: " + fileName + " to " + monthName + "/");
      }
    }

    threads[t].addLabel(label);
  }

  Logger.log("Done! Saved " + savedCount + " receipt(s) to Google Drive.");
}

// ============================================================
// REPAIR FUNCTION (ONE MONTH BACK)
// ============================================================
// What it does:
// - Targets the previous calendar month (relative to today).
// - Creates a NEW reconciliation folder under:
//     Train Tickets / YYYY / "Reconciled - <Month> <Year>"
// - Searches TrainPal emails from the last N days (CONFIG.repairSearchDaysBack)
// - For each matching receipt attachment whose parsed travel date is in the target month,
//   it saves it into the reconciliation folder using the corrected name.
// - Does NOT delete or move existing files (safe).
// ============================================================
function repairPreviousMonth() {
  var now = new Date();
  var target = new Date(now.getFullYear(), now.getMonth() - 1, 1, 12, 0, 0); // previous month, day 1
  var targetYear = target.getFullYear();
  var targetMonth = target.getMonth(); // 0-11
  var targetMonthName = getMonthName_(targetMonth);

  var rootFolder = getOrCreateFolderSmart_(null, CONFIG.rootFolderName);
  var yearFolder = getOrCreateFolderSmart_(rootFolder, targetYear.toString());

  var reconciliationFolderName = "Reconciled - " + targetMonthName + " " + targetYear;
  var reconFolder = getOrCreateFolderSmart_(yearFolder, reconciliationFolderName);

  // Gmail query: keep it bounded for performance; adjust if you book further ahead
  var query =
    "from:" +
    CONFIG.senderEmail +
    " newer_than:" +
    CONFIG.repairSearchDaysBack +
    "d has:attachment";

  var threads = GmailApp.search(query);

  if (threads.length === 0) {
    Logger.log("No TrainPal emails found in the last " + CONFIG.repairSearchDaysBack + " days.");
    return;
  }

  Logger.log(
    "Repair mode: scanning " +
      threads.length +
      " thread(s) for travel dates in " +
      targetMonthName +
      " " +
      targetYear +
      "..."
  );

  var savedCount = 0;

  for (var t = 0; t < threads.length; t++) {
    var messages = threads[t].getMessages();

    for (var m = 0; m < messages.length; m++) {
      var message = messages[m];
      var subject = (message.getSubject() || "").toLowerCase();
      var body = (message.getPlainBody() || "").toLowerCase();
      var content = subject + " " + body;

      // Route filter still applies
      if (
        content.indexOf(CONFIG.routeKeywordA) === -1 ||
        content.indexOf(CONFIG.routeKeywordB) === -1
      ) {
        continue;
      }

      var messageDate = message.getDate();
      var attachments = message.getAttachments();

      for (var a = 0; a < attachments.length; a++) {
        var attachment = attachments[a];
        var attachmentName = (attachment.getName() || "").toLowerCase();

        if (attachment.getContentType() !== "application/pdf") continue;

        if (
          CONFIG.receiptKeyword &&
          attachmentName.indexOf(CONFIG.receiptKeyword.toLowerCase()) === -1
        ) {
          continue;
        }

        var travelDate =
          extractTravelDateFromAttachmentName_(attachment.getName(), messageDate) ||
          extractTravelDateFromEmail_(message) ||
          null;

        if (!travelDate) continue;

        if (travelDate.getFullYear() !== targetYear || travelDate.getMonth() !== targetMonth) {
          continue;
        }

        var fileName = buildFileName_(travelDate);
        fileName = getUniqueFileName_(reconFolder, fileName);

        reconFolder.createFile(attachment.copyBlob().setName(fileName));
        savedCount++;
      }
    }
  }

  Logger.log(
    "Repair complete. Saved " +
      savedCount +
      " corrected receipt(s) into: " +
      targetYear +
      "/" +
      reconciliationFolderName
  );
}

// ============================================================
// HELPERS
// ============================================================

function buildFileName_(date) {
  var shortMonth = getShortMonthName_(date.getMonth());
  var shortDay = getShortDayName_(date.getDay());
  var dayNum = padZero_(date.getDate());
  var monthNum = padZero_(date.getMonth() + 1);
  var year = date.getFullYear();

  return shortMonth + " - " + shortDay + " - " + dayNum + "-" + monthNum + "-" + year + ".pdf";
}

function getUniqueFileName_(folder, fileName) {
  var baseName = fileName.replace(/\.pdf$/i, "");
  var candidate = fileName;
  var counter = 2;

  while (folder.getFilesByName(candidate).hasNext()) {
    candidate = baseName + " (" + counter + ").pdf";
    counter++;
  }

  return candidate;
}

// --- Date parsing (PRIMARY): attachment filename ---
function extractTravelDateFromAttachmentName_(filename, messageDate) {
  if (!filename) return null;

  // Common TrainPal-ish pattern: "..._21_Feb_0655.pdf"
  // Also handles: "...-21-Feb-0655.pdf" etc.
  var m = filename.match(/\b(\d{1,2})[ _-](Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ _-]/i);
  if (!m) return null;

  var day = parseInt(m[1], 10);
  var monStr = m[2].substr(0, 1).toUpperCase() + m[2].substr(1, 2).toLowerCase();
  var monthMap = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };
  var month = monthMap[monStr];
  if (month === undefined || isNaN(day)) return null;

  // Year heuristic from message date (handles year boundary)
  var year = messageDate.getFullYear();
  var msgMonth = messageDate.getMonth();

  // If message is Dec and travel is Jan -> next year
  if (msgMonth === 11 && month === 0) year += 1;
  // If message is Jan and travel is Dec -> previous year (rare, but symmetric)
  if (msgMonth === 0 && month === 11) year -= 1;

  // Midday avoids DST/timezone rollover surprises
  return new Date(year, month, day, 12, 0, 0);
}

// --- Date parsing (FALLBACK): email subject/body ---
function extractTravelDateFromEmail_(message) {
  var text = ((message.getSubject() || "") + " " + (message.getPlainBody() || ""))
    .replace(/\s+/g, " ")
    .trim();

  // Matches: "Sat, Feb 21, 2026"
  var m = text.match(/\b(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat),\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{1,2}),\s+(\d{4})\b/);
  if (!m) return null;

  var monthMap = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };
  var month = monthMap[m[1]];
  var day = parseInt(m[2], 10);
  var year = parseInt(m[3], 10);

  if (month === undefined || isNaN(day) || isNaN(year)) return null;
  return new Date(year, month, day, 12, 0, 0);
}

// --- Folder + label helpers ---
function getOrCreateLabel_(labelName) {
  var label = GmailApp.getUserLabelByName(labelName);
  if (!label) {
    label = GmailApp.createLabel(labelName);
    Logger.log('Created Gmail label: "' + labelName + '"');
  }
  return label;
}

// SMART folder getter:
// - avoids creating duplicate month folders when casing/spacing differs
// - e.g. "February" vs " february "
// - also helps prevent accidental typos creating new folders
function getOrCreateFolderSmart_(parentFolder, folderName) {
  var desired = normaliseFolderName_(folderName);

  // Enumerate existing folders under the parent and do a normalised match.
  var it = parentFolder ? parentFolder.getFolders() : DriveApp.getFolders();
  while (it.hasNext()) {
    var f = it.next();
    if (normaliseFolderName_(f.getName()) === desired) {
      return f;
    }
  }

  // Not found -> create with canonical name
  if (parentFolder) {
    Logger.log('Created folder: "' + folderName + '"');
    return parentFolder.createFolder(folderName);
  } else {
    Logger.log('Created root folder: "' + folderName + '"');
    return DriveApp.createFolder(folderName);
  }
}

function normaliseFolderName_(name) {
  return (name || "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim();
}

// --- Date formatting helpers ---
function getMonthName_(monthIndex) {
  var months = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December",
  ];
  return months[monthIndex];
}

function getShortMonthName_(monthIndex) {
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  return months[monthIndex];
}

function getShortDayName_(dayIndex) {
  var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  return days[dayIndex];
}

function padZero_(num) {
  return num < 10 ? "0" + num : num.toString();
}

// ============================================================
// SETUP: daily trigger (same as before)
// ============================================================
function setupDailyTrigger() {
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "collectTrainTickets") {
      ScriptApp.deleteTrigger(triggers[i]);
    }
  }

  ScriptApp.newTrigger("collectTrainTickets")
    .timeBased()
    .everyDays(1)
    .atHour(8)
    .create();

  Logger.log("Daily trigger created! Runs every day between 8-9 AM.");
}

// ============================================================
// OPTIONAL UTILITIES
// ============================================================

// Test search (no processing label changes)
function testSearchWithoutProcessing() {
  var query = "from:" + CONFIG.senderEmail + " has:attachment";
  var threads = GmailApp.search(query);

  Logger.log("Total TrainPal emails with attachments: " + threads.length);

  for (var t = 0; t < threads.length; t++) {
    var messages = threads[t].getMessages();
    for (var m = 0; m < messages.length; m++) {
      var message = messages[m];
      var content = ((message.getSubject() || "") + " " + (message.getPlainBody() || "")).toLowerCase();

      var routeMatch =
        content.indexOf(CONFIG.routeKeywordA) !== -1 &&
        content.indexOf(CONFIG.routeKeywordB) !== -1;

      var attachments = message.getAttachments();
      var attachmentNames = [];
      for (var a = 0; a < attachments.length; a++) {
        attachmentNames.push(attachments[a].getName() + " (" + attachments[a].getContentType() + ")");
      }

      Logger.log(
        "---\n" +
          "Subject: " + message.getSubject() + "\n" +
          "Message date: " + message.getDate() + "\n" +
          "Route match: " + (routeMatch ? "YES" : "NO") + "\n" +
          "Attachments: " + attachmentNames.join(", ")
      );
    }
  }
}

// Remove processed label from all threads (global reset)
function resetProcessedEmails() {
  var label = GmailApp.getUserLabelByName(CONFIG.processedLabelName);
  if (!label) {
    Logger.log("No processed label found. Nothing to reset.");
    return;
  }

  var threads = label.getThreads();
  for (var t = 0; t < threads.length; t++) {
    threads[t].removeLabel(label);
  }

  Logger.log(
    "Reset complete. Removed processed label from " +
      threads.length +
      " thread(s). Run collectTrainTickets() again to reprocess."
  );
}